# Практикум 09 - Динамичен полиморфизъм

## Общи изисквания:
За всички класове искаме да е спазен принципът `RAII (Resource Acquisition Is Initialization)`

## Задача 01 - Герои
Да се реализира клас `Character`, който да представлява герой в игра. Всеки герой трябва да има име, точки атака и точки живот. Да се реализират следните методи:
- dealDamageTo(const Character& other, double points) const - нанася щети по подадения герой;
- takeDamage(double points) - поема щети;
- heal(double points) - възвръща точки живот;
- print() const - извежда подробна информация за героя в следния формат:
```
Name: {name}
Type: Ordinary Character
HP: {health_points}
DMG: {damage_points}
```

Да се реализира клас `Knight`, наследник на клас `Character`, който представлява рицар в игра. За разлика от обикновения герой, рицарят блокира 25% от нанесените му щети и възвръща с 5% повече точки живот. Освен това при извеждането на информация за рицаря, да се извежда Knight вместо Ordinary Character.

Да се реализира клас `Archer`, наследник на клас `Character`, който представлява стрелец в игра. За разлика от обикновения герой, стрелецът нанася 33% повече щети, но поема 15% повече щети. Освен това при извеждането на информация за стрелеца, да се извежда Archer вместо Ordinary Character.

Да се реализира клас `Game`, който представлява игра, в която има списък от герои, които се бият помежду си. Да се реализират следните методи:
- add(const Character* character) - добавя герой в списъка;
- battle(const char* attacker, const char* target) - героят с име {attacker} напада героя с име {target}. Ако някой от героите не е част от списъка да се изведе подходящо съобщение. Ако точките живот на героя с име {target} паднат под 0, героят да се премахне от списъка и да се изведе подходящо съобщение;
- heal(double amount) - всички герои в списъка възвръщат {amount} точки живот;
- print() const - извежда подробна информация за оцелелите до момента герои.

## Задача 02 - Банка
Да се реализира клас `Account`, който представлява банкова сметка. Всяка банкова сметка има уникален идентификатор, баланс и лихвен процент. Да се реализират следните методи:
- deposit(double amount) - депозира подадената сума в сметката;
- withdraw(double amount) - ако има достатъчен баланс в сметката, тегли подадената сума от сметката. Иначе изкарва подходящо съобщение;
- addInterest() - увеличава баланса спрямо лихвения процент;
- operator==(const char* id) - проверява дали сметката има подадения уникален идентификатор;
- operator<< - извежда подробна информация за сметката.

Да се реализира клас `CheckingAccount`, който представлява разплащателна сметка. Освен характеристиките на обикновената сметка, разплащателната сметка има и такса за транзакция, която се приспада при всяко теглене.

Да се реализира клас `SavingsAccount`, който представлява спестовна сметка. Освен характеристиките на обикновената сметка, спестовната сметка има и лимит за теглене. Ако при теглене клиент опита да изтегли по-голяма сума от лимита, да се откаже тегленето и да се изведе подходящо съобщение.

Да се реализира клас `SalaryAccount`, който представлява сметка за превод на работна заплата. Освен характеристиките на обикновената сметка, сметката за превод на работна заплата има и месечна заплата. При добавянето на лихвения процент, след увеличаването на баланса да се добави и 5% от работната заплата.

Да се реализира клас `Bank`, който представлява банка, в която има множество банкови сметки. Да се реализират следните методи:
- add(const Account* account) - добавя сметка в банката;
- remove(const char* id) - премахва сметка от банката по подадения уникален идентификатор;
- depositTo(const char* id, double amount) - към сметката с подадения уникален идентификатор депозира подадената сума;
- withdrawFrom(const char* id, double amount) - от сметката с подадения уникален идентификатор опитва да изтегли подадената сума;
- addInterest() - увеличава баланса на всички сметки спрямо лихвения им процент;
- operator<< - извежда подробна информация за сметките в банката.