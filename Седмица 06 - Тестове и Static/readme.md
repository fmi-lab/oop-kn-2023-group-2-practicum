# Практикум 06 - Тестове и Static

## Задача 00 - Символен низ
Да се реализират автоматични тестове за класа `String` от седмица 04.

## Задача 01 - Кола
Да се реализира клас `Car`, който представлява кола, която има марка, модел, идентификационен номер (номер на рамата), средна скорост и изминато разстояние. Идентификационният номер на всяка кола се определя от реда и на създаване. Да се реализира метод drive, който пресмята за колко часа колата ще измине подаденото разстояние. След всяко извикване на drive да се актуализира изминатото разстояние. Освен това за всеки 100 изминати километра, средната скорост на колата намалява с 1 км/час, но не може да падне под 50% от първоначалната скорост. Да се реализират оператор ==, който проверява дали 2 коли са от един и същи модел и марка, и операторите за вход и изход. Да се напишат автоматични тестове за класа, без операторите за вход и изход.

### Бонус:
С помощта на `std::stringstream` да се напишат автоматични тестове и за операторите за вход и изход.

## Задача 02 - Logger
Да се реализира клас `Logger`, който записва съобщения в текстови файлове. Класът трябва да има само една инстанция. Да се реализират 3 метода - log, error и warning, които да записват съобщения съответно в три текстови файла - log.txt, error.txt и warning.txt. Да се предефинира операторът за изход, който да прави същото като метода log. (Сигнатурата на метода да е следната: `Logger& operator<<(const char* message)`).

### Упътване:
Щом като класът трябва да има само една инстанция, то той трябва да следва Singleton Design Pattern. За него е характерно, че конструкторът е private, а конструкторът за копиране и операторът = са изтрити. Освен това трябва да има публичен метод `getInstance`, който съдържа статична променлива от тип Logger - инстанцията на класа, и връща инстанцията. По този начин при първото извикване на getInstance, статичната променлива ще се инициализира, а при всяко следващо само ще връща инстанцията. Понеже не искаме при всяко извикване на методите log, error и warning да отваряме наново файловете, в класа ще пазим 3 член-данни за 3-те файла и при първото извикване на getInstance ще ги отваряме. Това от своя страна означава, че въпреки че изтрихме конструктора за копиране и операторът =, ще ни е нужен деструктор, който да затваря файловете. Това е един от малкото случаи, който е изключение от правилото за голямата четворка.