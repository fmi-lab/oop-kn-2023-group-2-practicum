# Практикум 16 - Множествено наследяване

## Задача 01 - Пътешествия (първа задача от второ контролно по ООП на КН 2022 г.)
Да се реализира клас за пътешествие с полет със самолет (AirTravel). Класът съдържа: 
- номер на полет (flightNumber) – низ с произволна дължина от тип char*;
- времетраенето на полета (duration) – задава се в минути.

Да се реализира клас за пътешествие с кола (CarTravel). Класът съдържа:
- регистрационен номер на превозно средство (regNumb) – представлява масив от четири цифри;
- брой километри, които ще бъдат изминати (distance);
- времетраене на пътуването с кола (също с име duration) – задава се в минути.

Да се реализира клас за комбинирано пътешествие (CombinedTrip), при което има точно едно пътуване с кола и едно пътуване със самолет. Класът притежава всички характеристики на описаните по-горе класове и две допълнителни полета:
- списък от забележителности, които ще бъдат посетени по време на пътуването (destinations) – представя се чрез динамичен масив от низове от тип char* с произволна дължина;
- свободно време за почивка между пътуванията (freeTime) – задава се в минути.

Да се реализира метод `getDuration`, който връща общото време за пътешествието, което включва времето за пътуване с кола, това за пътуване със самолет и свободното време. Да се реализира метод `print`, който извежда цялата информацията за пътешествието на екрана.

## Задача 02 - Ястия (първа задача от писмен изпит по ООП на КН 2019 г.)
Да се напише програма, която позволява създаване и работа с множество от ястия. За целта да се създаде клас ястие (Dish). Всяко ястие (Dish) се характеризира със:
- Списък от продукти (ingredientsNames) - всеки продукт се задава чрез неговото име с произволна дължина. Списъкът съдържа максимум 100 продукта;
- Време за приготвяне (cookTime) - измерва се в минути. Да се реализира функция print, която извежда информацията за едно ястие на екрана.

За целта на нашата задача различаваме два основни типа ястия:
- Ястие с месо (MeatDish) - съдържа допълнителна член-данна месо (meat), която съдържа името на основния протеин в ястието. Член-данната meat може да приема една от следните стойности: “chicken”, “beef”, “pork”, “duck”. Да се реализира функция print, която извежда собствените и наследените данни за ястието;
- Ястие с морска храна (SeafoodDish) - съдържа допълнителна член-данна морска храна (seafood), която съдържа името на основния протеин в ястието. Член-данната seafood може да бъде име на риба или друг морски дар с произволна дължина. Валидация на стойността на член-данната не е необходима. Да се реализира функция print, която извежда собствените и наследените данни за ястието.

Да се реализира клас SurfAndTurf, представляващ ястие, което комбинира морски дарове и месо. Да се напише функция print, която извежда цялата информация за ястието. Да се реализира главна функция (main), която:
- Създава обект от тип SurfAndTurf,
- Създава указател към Dish и го свързва с динамично създаден обект MeatDish.
(Използвайте оператор new)
- Освобождава заделената памет, където е нужно.

## Задача 03 - HTML
Да се реализират следните класове, които представляват йерархия от HTML елементи:
- `BlockElement` - HTML елемент, който има зададен в CSS свойството `display: block`. Класът се характеризира с широчина, височина и дебелина на ръба (всички са в пиксели). Да се реализира метод `area`, който връща колко пиксела от екрана общо заема елемента (да се брои и мястото заето от ръба). 
- `FormElement` - наследник на `BlockElement`, който представлява HTML елемент, който е част от `form` елемент. Освен наследените характеристики, класът да има и име, представляващо `name` атрибута.
- `Label` - наследник на `FormElement`, който представлява `label` елемент. Освен наследените характеристики, класът да има и `title` - член-данна от тип std::string, която представлява текста, който стои в елемента.
- `Interactable` - наследник на `BlockElement`, който представлява HTML елемент, с който потребителят може да взаимодейства. Класът да има метод `interact`, който извършва конкретно действие при взаимодействие на потребител с елемента. Методът да бъде чисто виртуален.
- `Input` - наследник на `FormElement` и `Interactable`, който представлява `input` елемент. Освен наследените характеристики, класът да има и `value` - член-данна от тип std::string, която представлява стойността на елемента. Методът `interact` да подканва потребителя да въведе стойност и след това я запазва. Да се реализира селектор, който връща стойността в елемента.
- `Form` - `form` елемент. Класът да съдържa списък от елементи, които са част от формата. Да се реализира метод `data`, който връща вектор от стойностите на всички `Input` елементи във формата.
- `SubmitButton` - наследник на `FormElement` и `Interactable`, който представлява `button` елемент с атрибут `type="submit"`. Освен наследените характеристики, класът да има и член-данна от тип `Form`, която представлява формата, за която е закачен бутонът. Методът `interact` да "изпраща" стойностите на `Input` елементите от формата на потребителя (под "изпраща" ще разбираме извежда на екрана).

За всеки от горните класове да се реализира метод `print`, който извежда подробна информация за техните характеристиките.