# Практикум 12 - Линеен едносвързан списък

## Общи изисквания:
Всички функции, които по някакъв начин променят реда на елементите в линейния едносвързан списък, да го правят само чрез размяна на кутиите им, а не директно на стойностите.

## Задача 01 - Шаблон на линеен едносвързан списък
Да се реализира шаблон на линеен едносвързан списък `LinkedList<T>`. Да се реализират следните методи към него:
- bool empty() const - проверява дали списъкът е празен;
- std::size_t size() const - връща броя на елементите в списъка;
- void insertFirst(const T& element) - добавя елемент към началото на списъка;
- void insertLast(const T& element) - добавя елемент към края на списъка;
- void removeFirst() - премахва първия елемент на списъка;
- void removeLast() - премахва последния елемент на списъка;
- void append(const LinkedList\<T\> other) - "закача" елементите на подадения списък към текущия като запазва реда им;
- void reverse() - обръща реда на елементите в списъка;
- void unique() - премахва повтарящите се елементи от списъка;
- void filter(std::function<bool(const T&)> predicate) - премахва всички елементи от списъка, които не отговарят на подадения предикат;
- LinkedList\<U\> map(std::function<U(const T&)> operation) const - връща нов списък, съдържащ елементите от текущия след прилагането на подадената операция над всеки един от тях;
- U reduce(std::function<U(const T&)> operation, U nullValue) const - връща резултата от прилагането на подадената операция върху всеки един от елементите на списъка, натрупвайки го в подадената начална стойност (дясно свиване);
- bool any(std::function<bool(const T&)> predicate) const - проверява дали в списъка има елемент, който отговаря на подадения предикат;
- bool all(std::function<bool(const T&)> predicate) const - проверява дали всички елементи в списъка отговарят на подадения предикат;
- void sortBy(std::function<bool(const T&, const T&)> comparator = std::less\<T\>()) - сортира списъка като използва подадената функция за сравнение на елементите;
- void partition(std::function<bool(const T&)> predicate) - пренарежда елементите на списъка, като тези, които отговарят на подадения предикат са в началото, а останалите - в края.

### Забележка:
`std::less<T>` е структура, която има единствен метод `bool operator()(const T& lhs, const T& rhs) const`, който извиква `operator<` за елементи от подадения тип `T`.

## Задача 02 - Итератор
Да се реализира итератор към линейния едносвързан списък от `Задача 01`. Да се реализират следните методи към итератора:
- bool valid() const - проверява дали итераторът е валиден, т.е. дали елементът, към който сочи, е част от списъка;
- bool operator!=(const LinkedListIterator& other) const - проверява дали два итератора са различни;
- LinkedListIterator\<T\>& operator++() - премества итератора една позиция надясно;
- T& operator*() - връща стойността, сочена от итератора, с възможност за промяна;
- const T& operator*() const - връща стойността, сочена от итератора, без възможност за промяна;

Освен това да се добавят следните методи към линейния едносвързан списък от `Задача 01`:
- LinkedListIterator\<T\> begin() const - връща итератор към първия елемент на списъка;
- LinkedListIterator\<T\> end() const - връща итератор след последния елемент на списъка;
- void insertAfter(const T& element, const LinkedListIterator\<T\>& position) - добавя елемент в списъка след подадената позиция;
- void insertBefore(const T& element, const LinkedListIterator\<T\>& position) - добавя елемент в списъка преди подадената позиция;
- void removeBefore(const LinkedListIterator\<T\>& position) - премахва елемента след този, сочен от подадения итератор;
- void removeAt(const LinkedListIterator\<T\>& position) - премахва елемента на подадената позиция;
- void removeAfter(const LinkedListIterator\<T\>& position) - премахва елемента преди този, сочен от подадения итератор;
- LinkedListIterator\<T\> findBy(std::function<bool(const T&)> predicate) const - връща позицията на първия елемент отговарящ на подадения предикат. Ако такъв елемент не съществува да се върне невалидна позиция.

## Задача 03** - Адаптор на итератор
Да се реализира `MapIterator<I>` - адаптор на итератор, който прилага дадена функция над всеки от елементите на контейнера при обхождане. Да се демонстрира коректността на реализацията в контекстта на предните две задачи.

### Упътване:
Потърсете информация как работи `std::view concept` и по-конкретно - `std::views::transform`.